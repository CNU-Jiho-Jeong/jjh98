# RAID

- 네트워크를 구성하려면 많은 트래픽을 견뎌야 하고, 어마어마한 용량을 필요로 한다. 일반 스토리지 하나로는 그것을 감당할 수 없기에, 여러 개의 스토리지를 사용해 하나의 디스크처럼 사용하게 되는데 이러한 개념을 Redundant Array of Inexpensive/Independent Disk라고 부른다.
 
- 기대 효과로는

   - 대용량의 단일 볼륨을 사용하는 효과
   - 디스크 I/O 병렬화로 인한 성능 향상
   - 데이터 복제로 인한 안정성 향상.

- 주 사용 목적은 (고가용성을 보장하는) 무정지 구현과 고성능 구현으로 구분되며, 무정지 구현은 RAID 1, 고성능은 RAID 0로 대표된다.

- 하드디스크의 느린 속도를 보완하기 위해 만든 기술로, RAID의 구성 방식에 따라 성능, 용량이 바뀌게 된다.

- 일반적으로 하드웨어 RAID라고 부르는 하드웨어 제조업체에서 여러 개의 하드디스크를 가지고 장비를 만들어 그 자체를 공급하는 방식은 안정적이지만, 매우 비싸서 함부로 이용하기 부담스럽고, 따라서 구성을 위해 좀 더 저렴하고 안전하게 데이터의 저장이 가능한 소프트웨어 RAID 방식을 많이 사용한다. 
  고가의 하드웨어 RAID의 대안이며 운영체제에서 자체적으로 지원하는 방식이기도 하다.


# RAID의 레벨

- Standard RAID 레벨에는 대표적으로 Linear RAID, RAID 0, 1, 5, 6이 있다. 디스크의 개수는 N으로 표시한다.

![image](https://user-images.githubusercontent.com/108641325/193213138-fffd7770-ff10-4604-bd31-127d3c257136.png)


### Linear RAID

- 말 그대로 '이어붙인 하드디스크'. 1TB 하드가 3개라면 정보를 저장할 때 위에서부터 순차적으로 저장하여 3TB를 사용하는 방식으로, 가장 고전적이라고 할 만하다.

### RAID 0 (Striping)

- 최소 2개의 하드디스크를 사용, 하나의 정보를 2개 이상의 디스크에 나눠서 저장한다. Linear RAID보다 저장속도의 효율이 좋다. 이론적으로 단일 디스크를 사용하는 것에 비해 N배의 성능을 보장한다.

- 하지만 정보를 나눠담은 하나의 디스크라도 고장나면 모든 정보를 사용할 수 없게 되므로 신뢰성이 낮다고 할 수 있다.

- 오류검출 기능이 없어 멤버 디스크를 늘릴수록 안정성이 떨어진다.

- 또한 RAID 시키는 하드디스크 용량이 각각 다르게 되면 공간 효율이 100%가 될 수 없는데, 가장 작은 하드디스크의 용량에 맞춰 저장되기 때문.

- 때문에 이 방식을 사용하게되면 서로 호환이 되는 동일 제조사, 동일 용량의 디스크를 사용하는 것이 일반적이다.

- 이미지 프로세싱, 데이터베이스 캐싱 등 빠른 입출력 성능을 필요로하며, 데이터 손실이 문제되지 않는 환경에서 쓰일 수 있지만, 상용 환경에서는 사용하지 않는 것이 좋다.

![image](https://user-images.githubusercontent.com/108641325/193213202-2fb91d6a-a1d8-4ddb-8e6b-204229973168.png)


### RAID 1 (Mirroring)

- 미러링 방식이라고 부르며 동일한 데이터를 2개 이상의 하드디스크에 동일하게 저장하므로 저장효율이 반토막 난다.

- 공간 효율은 좋지 않지만, 하나의 디스크가 고장나도 다른 디스크는 문제 없이 사용가능하므로 정보 저장의 신뢰성이 높다고 할 수 있다.

- 멤버 디스크가 늘더라도 저장 공간은 증가하지 않지만, 가용성이 크게 증가하며 서버에서 끊김 없이 지속적으로 서비스를 제공하기 위해 사용한다.

- 쓰기 속도는 이론적으로 소폭 하락하는데 이는 하향평준화가 기준이기 때문. 하지만 동일 제품으로 구성한 경우에는 차이가 없을 수 있다.

- 백업의 목적 보다는 가용성에 초점을 맞추고 사용하는 것이 옳다. 물론, 디스크 고장 상황에서 백업과 유사한 보호 기능을 제공하며, 가장 최신화 된 데이터를 항상 유지할 수 있으나 랜섬웨어 등에 대응할 수 없다는 점에서 반쪽짜리 백업에 불과하다.

- 비용효율이 좋지 않다.

![image](https://user-images.githubusercontent.com/108641325/193213424-9fb53b67-bcb5-4542-ad47-51f97493365d.png)


### RAID 5

- RAID 0와 RAID 1의 장점을 조합해서 사용하는 방식. RAID 1의 데이터 안전성 + RAID 0의 빠른 저장속도와 공간효율.

- 제일 사용 빈도가 높다.

- 패리티(Parity)를 사용하게 되는데 일반적으로 하드디스크 7~10개를 연결하게 된다.

- 참고로 RAID 2, 3, 4 방식도 있지만 5보다 효율이 떨어지므로 잘 사용되지 않는다.

![image](https://user-images.githubusercontent.com/108641325/193213451-bb607d03-06c3-407a-bb84-7aa74c5ef59a.png)

![image](https://user-images.githubusercontent.com/108641325/193213469-3957e0f7-81cc-4b78-8499-51f531b53ed2.png)



- Block 단위로 스트라이핑을 하고, error correction을 위해 패리티를 한개의 디스크에 저장하는데, 패리티를 저장하는 디스크를 고정하지 않고, 매 번 다른 디스크에 저장한다.

- 패러티를 이용해서 하나의 디스크가 문제가 생겨도 잃어버린 데이터를 복구 할 수 있다.

- 패리티를 한 디스크에 넣지 않고 각 멤버 디스크에 순환적으로 저장, 입출력 병목 현상을 해결할 수 있다. 용량 및 성능이 단일 디스크 대비 N-1 배 증가한다.

- 하나의 멤버 디스크 고장에는 견딜 수 있지만, 두개 이상 고장나면 데이터가 모두 손실된다.

- DB 서버 등 큰 용량과 무정지 복구 기능을 동시에 필요로 하는 환경에서 주로 사용된다.

- 매 쓰기 작업에 패리티 연산 과정이 추가되어 성능을 보장하려면 패리티 연산 전용 프로세서와 메모리를 사용해야하고, 멤버 디스크도 3개 이상 사용해야하므로 초기 구축비용이 비싸다는 단점이 있다. 최소 3개의 디스크로 구성 가능하다.

- 읽기 작업은 전체 디스크에 분산되어 속도가 향상되지만, 쓰기 작업은 성능이 약간 떨어진다. 적어도 둘 이상의 디스크 (데이터+패리티)에서 진행해야하기 때문.

- 가용성은 높은 편이나, 패리티 연산을 통해 데이터를 저장한다는 특징 때문에 까다롭다.

- 짝수 패리티 방식 예시.

   - 3개의 디스크에 정보를 나눠서 저장한 후 하나의 빈 정보를 따로 남은 디스크에 저장하게 된다. 그렇게 남은 디스크의 저장 공간을 패리티라고 부르며, 아래 예시처럼 sdb 디스크가 고장나게 되면 패리티를 포함한 데이터의 값을 짝수로 만들어야 하므로 이를 통해 패리티에 들어갈 숫자를 인식, 데이터를 복구하게 된다.

![image](https://user-images.githubusercontent.com/108641325/193213514-728392b0-e2c3-4219-b933-de3e4e7dc9bb.png)


### RAID 6

- RAID 5에서 성능, 용량을 좀 더 줄이고, 안정성을 높인 레벨.

- Block 단위로 스트라이핑을 하고, error correction을 위해 패리티를 두 개의 디스크에 저장하는데, 패리티를 저장하는 디스크를 고정하기지 않고, 매 번 다른 디스크에 저장한다. → RAID 5와 비슷하다.

- 용량 및 성능이 단일 디스크 대비 N-2배 증가한다.

- 패리티를 2개 사용하므로 RAID 5 보다 가용성이 높지만, 정보를 저장하지 않은 디스크 2개나 생겨 공간효율과 성능이 떨어지므로 활용 빈도는 조금 떨어진다.

- 5가 1개까지의 고장을 허용했다면 6은 2개까지는 허용된다.

- RAID 5보다 초기 구축비용이 비싸다. 최소 4개의 디스크로 구성되어야 하기 때문.

![image](https://user-images.githubusercontent.com/108641325/193213544-60ea2299-7ac4-4f98-8fa8-1bcb97b09b05.png)


### Nested RAID (복합)

- 위의 0~6 레벨의 Standard RAID를 여러 개 중첩하여 사용한다.

- RAID 볼륨의 멤버로 다른 레이드 볼륨을 사용하는 형태.

- 멤버 디스크를 묶는 배열을 하위 배열, 하위 배열을 묶는 배열을 상위 배열이라고 한다.

### RAID 1+ RAID 0

- RAID 6보다 더 안정적이면서 RAID 5의 장점을 극대화하기 위해 RAID 1과 RAID 0의 장점을 조합하여 사용하는 방식.

- RAID 5가 패리티를 사용해 공간효율이 떨어졌지만, 이 방법은 1과 0의 방식을 직접 조합시켜 그러한 단점을 보완한 방식이라 할 수 있다. 신뢰성과 성능 두 가지 모두 만족하는 방법.

![image](https://user-images.githubusercontent.com/108641325/193213587-d60f056d-5bfb-4a73-8858-5b25d34596c1.png)

![image](https://user-images.githubusercontent.com/108641325/193213614-6c6bc3e5-3849-464b-bd29-75ba17345765.png)

![image](https://user-images.githubusercontent.com/108641325/193213627-8622e795-27a8-4b4d-8e65-9d61fd7566a1.png)


### RAID 5 + RAID 0



### RAID 5 + RAID 1

---

# RAID의 구현

- RAID 레벨이 논리적 구성 방법이었다면, RAID의 구현은 물리적 구성 방법.

### 하드웨어 RAID

- 별도의 RAID 카드를 장착하여 구현하는 방법.

- 이 카드에는 RAID를 관리하는 컨트롤러 칩셋과 방열판, 캐시로 사용하기 위한 메모리가 달려 있고, 디스크를 연결하기 위한 인터페이스(주로 SAS)가 달려있다. 전원 장애 시 캐시의 내용을 잠시나마 유지시키기 위해 배터리가 달려 있기도 하다.

- RAID 카드는 대부분 PCI-E 슬롯에 꽂아서 사용하며, OS부팅 이전 RAID 카드의 설정 페이지로 진입하여 관리하게 된다.

- RAID 구성 후 부팅을 하게 되면 OS에서는 구성이 완료된 RAID 볼륨만 확인할 수 있다. 즉, RAID를 구성하고 있는 단일 디스크의 정보는 RAID 카드를 통해서만 알 수 있는 셈.

- 카드에 달려 있는 별도의 컨트롤러 칩셋이 RAID를 관리하기 때문에 다른 방식에 비해 성능이 월등히 높다. 특히 별도의 패리티 연산이 필요한 5나 6에서 매우 높은 성능을 보여주며, RAID를 구성할 수 있는 최대 디스크 개수도 월등히 높다.

- RAID 카드와 연결되어 있는 디스크를 그대로 제거하여 다른 PC, 서버로 이동시키면 기존 운영하던 RAID 볼륨을 거의 100% 그래도 유지할 수 있다는 것도 장점.

- 별도의 RAID 카드를 사야하기 때문에 구축 비용이 많이 들고 RAID를 구성하는 단일 디스크의 분석을 거의 할 수 없다는 것이 단점이다.

- 장점 : 속도와 안정성 모두 최고급 / 단점 : 별도의 RAID 카드가 필요해 비용이 많이 든다

### 펌웨어(드라이버) RAID

- 드라이버 RAID, On-board RAID, 임베디드 RAID 등으로 불림.

- RAID 카드 대신 기능을 간략화한 RAID 칩을 탑재하고 펌웨어(드라이버)로 제어하여 구현하는 방법. 보통 OS 진입 전 BIOS 메뉴에서 RAID를 구현한다. OS에 관계 없이 작동하며, OS에서는 원래 장착한 디스크 대신 가상의 BIOS RAID 하드웨어가 표시된다. 즉, 별도의 드라이버 소프트웨어를 통한 관리가 불가능.

- 펌웨어 RAID는 OS부팅 전에 RAID를 구성하기 때문에 OS 변경에는 영향을 미치지 않는다. 따라서 OS를 바꿔도 RAID는 유효한 대신, 메인보드를 바꾸게 되면 더 이상 사용하지 못할 가능성이 크다.

- 원래 디스크를 가상 디스크가 대체하는 방식이다 보니, 용량이 다른 두 하드웨어를 묶었을 때 남은 공간은 활용 못하고 버려지는 단점이 있다.

- 전통적으로는 별도 RAID 컨트롤러를 사용하는 것이 안정성이 좋고 유지보수 등의 강점이 있는 것으로 알려져 있으나, 최근에는 메인보드 내장 RAID 컨트롤러 또한 상당한 성능을 보여주고 있다.

- 안정성 면에서도 별도의 RAID 컨트롤러 에 비해 부실하기 때문에 RAID Array가 깨졌을 시 데이터 복구는 힘들 수 있다.

- 하드웨어 RAID와 소프트웨어 RAID의 중간이라고 할 수 있겠다.

### 소프트웨어 RAID

- OS RAID라고도 함.

- RAID 소프트웨어(프로그램)을 이용하여 RAID를 구성하는 방식. OS부팅 이후 관련 프로그램을 실행하여 RAID를 구축하게 된다.

- OS가 인식하고 있는 블록 디바이스를 사용해서 구축하게 되며, OS의 디스크 관리메뉴에서 RAID를 구현하는 방법.

- 하드웨어 RAID와 다르게 RAID를 구성하고 있는 단일 디스크에 대한 분석을 할 수 있다.

- 단점으로는 OS 위에서 동작하는 프로그램이 관리하기 때문에 상대적으로 속도가 매우 느리고, 다른 프로그램들과 리소스(CPU, 메모리 등)을 같이 사용하기 때문에 전체적인 시스템의 성능이 떨어질 수도 있다.

- OS RAID는 메인보드를 바꾸더라도 해당 디스크만 제대로 꽂아주면 계속 레이드를 사용할 수 있지만, OS를 바꾸면 보통 사용하지 못한다. Windows의 경우 해당 RAID를 구성한 디스크가 모두 장착되어 있다는 전제 하에 새 OS 설치 후에도 디스크 가져오기 옵션을 통해 RAID 구성을 그대로 가져올 수 있다.

- OS에서 관리하므로 다양한 방법으로 RAID를 구성할 수 있으며, 특히 용량이 다른 두 제품이 경우 RAID를 구성하고 남는 공간에 단일 파티션, 또는 또 다른 RAID Array를 구성할 수도 있다.

- 파일시스템은 언제나 해당 OS에서 네이티브로 잘 지원되는 것을 사용하는 것이 안전하기 때문에, 호환성 측면에서는 메인보드 RAID 보다는 OS RAID가 좀 더 좋다, 고 한다.
