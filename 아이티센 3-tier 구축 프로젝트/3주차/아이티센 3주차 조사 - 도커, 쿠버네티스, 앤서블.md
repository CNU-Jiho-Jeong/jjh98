# 도커

- 컨테이너 기반의 오픈소스 가상화 플랫폼

- 쉽게 말하면, 도커는 컨테이너를 관리하는 플랫폼이다.

![image](https://user-images.githubusercontent.com/108641325/194745233-910892fc-03ce-4153-aec6-a775c2ecbef7.png)


- 여기서 말하는 컨테이너란 애플리케이션을 환경에 구애받지 않고 실행하는 기술을 말한다.

- 서버 제작과정에 견고함과 유연성, 편리함이 좋고 다른 사람이 만든 서버를 소프트웨어 사용하듯이 바로 가져다가 사용할수 있는 장점이 있다. 또한 여러 대에 배포할 수 있는 확장성도 지녔다.

---

### 1. 도커를 사용하는 궁극적인 이유

**1) 환경 표준화**

- 환경이 일정하지 않아서 생기는 문제를 해결할 수 있다.
개발하려고 하는 여러 어플리케이션을 구동할 때 운영체제가 서로 다르면 환경에 따라 조금씩 변경할 부분이 생긴다. 같은 Linux라고 하더라도 Ubuntu, CentOS, Debian은 서로 다른 환경이므로 여러 버전이 존재할 수도 있다.

**2) 개발 혹은 실행에 대한 환경 설정의 코드화**

- 개발된 어플리케이션을 내 컴퓨터에 설치해 사용하고자 할 때 '내 컴퓨터' 혹은 '내 사용 목적'에만 맞는 설정이 따로 필요할 수 있다. 예를 들어 환경 변수처럼 같은 OS라 하더라도 사용자에 따라 달라지는 구성이 있다. 만약 어플리케이션을 설치하거나 실행할 때 홈 디렉토리에 저장해야한다면 모든 사용자가 같은 홈 디렉토리를 사용하진 않을 것이다. 이 외에도 방화벽 설정, 사용자 권한 설정, Port 설정 등 어플리케이션을 설치할 때 컴퓨터에 맞게 변경해줘야하는 부분들이 있다. 이러한 문제를 해결하기 위해 수작업을 하게 된다면 많은 시간이 걸린다. 하지만 도커를 사용하면 환경 설정을 코드화 해놓았기 때문에 편하게 작업을 할 수 있는 것이다.

=> 즉, 표준화의 관점에서 이유를 찾을 수 있다!

=> 도커 컨테이너는 소프트웨어를 소프트웨어 실행에 필요한 모든 것을 포함하는 파일 시스템 안에 감싼다. 이는 실행 중인 환경에 관계 없이 언제나 동일하게 실행될 것을 보증한다.

---

### 2. 도커 사용

- 이미지: 컨테이너 실행에 필요한 파일과 설정값 등을 포함하고 있는 것. 변하지 않음

- 도커는 레이어(layer)라는 개념을 사용하고, 유니온 파일 시스템을 이용하여 여러개의 레이어를 하나의 파일시스템으로 사용할 수 있게 해준다.

![image](https://user-images.githubusercontent.com/108641325/194745238-5631f36b-55f1-46b0-8db4-fd968311185f.png)


- webapp 소스를 수정하면 A, B, C, nginx 레이어를 제외한 새로운 source(v2) 레이어만 다운받으면 되기 때문에 굉장히 효율적으로 이미지를 관리할 수 있다.

---

### 네이버 클라우드에서 컨테이너로 이미지 관리하기

**1) Object storage 생성**

  - Container Registry를 생성하기 전에 Object Storage를 먼저 생성해야 한다.
  
  ![image](https://user-images.githubusercontent.com/108641325/194745265-2ba3a7f2-3e72-4b06-add5-be655b8c1d2d.png)

  ![image](https://user-images.githubusercontent.com/108641325/194745272-100898d0-ea8d-4aa0-a3ee-3e2c457e755c.png)

  ![image](https://user-images.githubusercontent.com/108641325/194745277-0121bfdf-2d83-4b8d-a821-4de37f25aeee.png)

  ![image](https://user-images.githubusercontent.com/108641325/194745283-925fdd26-ecf5-454b-8a11-5d82cd42f053.png)

---

**2) Container Registry 생성**

![image](https://user-images.githubusercontent.com/108641325/194745303-1de763fb-9006-46e2-827e-01288c63a4c9.png)

![image](https://user-images.githubusercontent.com/108641325/194745306-ac20f6e9-1987-47d1-806f-7b95560f75c4.png)

![image](https://user-images.githubusercontent.com/108641325/194745311-134e91be-625e-4651-ac1e-3eac99fae2bb.png)

컨테이너 레지스트리는 네이버 클라우드 플랫폼의 서버 상품 및 도커 CLI와 통합하여 사용할 수 있다. 도커 CLI를 사용해 도커 컨테이너 이미지를 컨테이너 레지스트리로 쉽게 전달할 수 있고, 이미지를 직접 운영 서버에 가져와 배포할 수 있어 개발부터 서비스 배포까지 필요한 작업을 간소화할 수 있다.


# 쿠버네티스 헬름

![image](https://user-images.githubusercontent.com/108641325/194745384-5d6a6e29-f6be-4e4a-a728-ac1af96c42e3.png)

- 쿠버네티스 헬름이란 쿠버네티스 템플릿들을 모아서 관리하는 “패키지 매니지먼트 도구”이다.

- Docker 의 출시가 container 을 혁신하고, Container 을 쉽게 관리하고 배포해주는 kubernetes 가 등장했으며 Kubernetes 를 패키지로 관리해주는 것이 Helm 이다.

- 일반적으로 하나의 소프트웨어를 쿠버네티스에 배포하려면 컨테이너만을 배포해서는 사용하기 어려운 경우가 많다.

- 외부로 IP 를 노출하기 위한 서비스 배포, pod 를 관리할 deployment, 디스크 볼륨과 기타 정책 등등.

- Helm 은 애플리케이션 컨테이너 배포는 물론이고, 필요한 쿠버네티스 리소스를 모두 배포해주는 역할을 하며, 이 배포를 패키지 형태로 한다.

- IaaC fnf rbgysgjsns Terraform + 패키지 매니저인 npm 정도의 개념.

![image](https://user-images.githubusercontent.com/108641325/194745409-014fefee-6f81-4acc-a9c5-ad30079a4434.png)

- CLI 툴인 클라이언트로 Helm 이 있다.

  클라이언트는 Helm 서버 모듈과 통신을 하는데, 이 서버를 Tiller 라고 하고, Tiller 은 쿠버네티스 클러스터 내에 설치된다.

- helm 을 통해 인스톨하는 패키지가 Chart. 

  Chart 는 템플릿으로 설치하고자 하는 쿠버네티스 리소스의 설치 스크립트가 됨.

  Chart 들은 Helm Chart Repository 에 저장할 수 있다.

- 헬름은 차트와 차트 압축 파일을 만들고, 차트 저장소에 연결해 쿠버네티스 클러스터에 차트를 설치, 삭제할 수 있다. 배포 주기 관리도 가능.

- 헬름을 이용해서 잘 정리된 차트들로 필요한 애플리케이션을 빠르게 설치할 수 있다.

헬름 2 와 헬름 3

- 2 는 CLI 인 `헬름 클라이언트`와 쿠버네티스 클러스터 안에서 헬름 클라이언트의 명령을 받아 쿠버네티스 API 와 통신하는 `틸러 서버`로 구성된다.

  - 헬름 클라이언트는 로컬 서버에 차트를 만들거나, 차트 저장소들과 클러스터에 실행 중인 애플리케이션(헬름 차트로 실행) 릴리즈를 관리하는데 필요한 요청을 하는 역할
  
  -  틸러 서버 : 헬름 클라이언트의 요청을 받아 실제로 처리하는 역할. 차트나 릴리즈를 만드는 것, 차트와 설정의 조합, 클러스터의 차트와 릴리즈의 설치와 관리를 담당한다. 틸러서버와는 gRPC 를 사용해 통신한다.

**헬름을 사용하는 이유**

- 쿠버네티스 애플리케이션 관리

  헬름 차트는 복잡한 쿠버네티스 애플리케이션도 편리하게 정의하여 설치하거나 업그레이드할 수 있다.

  편리한 차트 작성, 버전 관리, 공유 및 게시

- 복잡성 관리

  차트는 매우 복잡한 앱도 표현하고, 반복적인 애플리케이션 설치를 제공하며 단일 권한으로 서비스할 수 있음.

- 쉬운 업데이트

  즉석(in-place) 업그레이드와 커스턴 훅은 통해 업데이트하는 수고를 줄여줌.

- 간단한 공유
  차트는 버전 관리, 공유, 퍼블릭 혹은 프라이빗 서버 호스팅이 편리함.

- 롤백

- 쿠버네티스 위에서 동작하는 애플리케이션은 다양한 리소스의 조합으로 구성되며, 애플리케이션 배포 시 이런 리소스를 개별적으로 생성하는 것이 아닌, 하나의 패키지로 묶어서 배포한다. 

  패키지로 묶어서 관리하면 여러 리소스들을 동시에 추가 및 업그레이드하기 편리해진다.

  예를 들어 `.yaml`은 정적 파일이기 때문에 리소스별로 yaml 파일을 만들어야 된다. 때문에 많은 리소스를 관리하게 될 때 yaml 파일에 대한 유지보수가 힘들어지게 된다.

- docker 가 단순히 프로세스 레벨에서 외부의 것을 가져다 쓸 수 있게 해준 것이라면, 쿠버네티스는 helm 을 이용, 프로세스(Pod)와 네트워크(Service), 저장소 (Persistent Volume)등 애플리케이션에서 필요한 모든 자원들을 외부에서 가져올 수 있게 한다.

# 앤서블

**앤서블이란**

:Ansible 은 IaC 를 지향하는 오픈소스 기반의 자동화 관리 도구 입니다. 자동 구축/관리 하려는 원격 인프라에 무언가 명령을 전달하는 방식으로 동작합니다.

-Infrastructure as Code (IaC)
인프라를 코드 기반으로 자동 설치 및 구축/관리/프로비저닝 하는 프로세스

**특징**

1) Agentless

명령을 내려주는 Controller 서버와 원격 서버에 설치된 Agent 들이 명령을 주고받는 방식으로 동작하는 Chef/Puppet 과 같은 기존 IaC 솔루션들과 다르게 앤서블(Ansible)은 SSH 를 기반으로 원격 서버에 명령을 전달하기 때문에 각 원격서버에 접속해서 agent 를 설치해줄 필요가 없습니다.

2) 접근 용이성

앤서블은 playbook 이라는 원격 서버에 전달할 명령들을 모아둔 명령집을 YAML 형식의 파일로 관리 합니다. 가독성이 좋은 YAML 파일로 접근이 용이합니다.

3) 멱등성 (idempotence)

멱등성이란 여러번 수행해도 같은 결과를 내는 성질을 말합니다. 앤서블은 YAML 로 관리되는 명령집을 여러번 수행하더라도 언제나 같은 결과가 나올 수 있도록 여러가지 관리를 합니다.


